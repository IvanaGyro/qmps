import cirq 
from qmps.ground_state import Hamiltonian
from xmps.spin import paulis, U4, swap
import numpy as np
import numpy.random as ra
from qmps.ground_state import Hamiltonian
from qmps.represent import get_env_exact, State, FullStateTensor, FullEnvironment
from qmps.represent import ShallowStateTensor, split_2s, ShallowCNOTStateTensor
from qmps.represent import ShallowFullStateTensor
import math
import matplotlib.pyplot as plt
import matplotlib as mpl
from functools import reduce
from scipy.optimize import minimize_scalar
from tqdm import tqdm
mpl.style.use('pub_fast')
X, Y, Z = paulis(0.5)
π = np.pi

dt = 0.1

def gate(v):
    #return ShallowCNOTStateTensor(2, v[:-1])
    return ShallowFullStateTensor(2, v)
    #return FullStateTensor(U4(v))

def op_state(params):
    assert len(params)==30
    p1, p2 = np.split(params, 2)
    qbs = cirq.LineQubit.range(6)
    C = cirq.Circuit.from_ops([gate(p1)(*qbs[:2]), 
                               gate(p1)(*qbs[4:]),
                               gate(p2)(*qbs[3:5]),
                               gate(p2)(*qbs[2:4]),
                               cirq.SWAP(*qbs[:2])])
    s = cirq.Simulator()
    return s.simulate(C).final_state

def op_H(H):
    #H = np.eye(4)
    return reduce(np.kron, [np.eye(2), np.eye(2), np.eye(2), H, np.eye(2)]) - np.kron(np.kron(np.eye(2), swap()), np.eye(8))

def sinusoids(H, state_function, parameters, args=()): 
    def ϵ(x):
        return np.real(state_function(x, *args).conj().T@H@state_function(x, *args))
    I = np.eye(len(parameters))
    xs = np.linspace(-π, π, 101)
    for i in range(15):
        es = []
        for x in xs:
            es.append(ϵ(parameters+x*I[i]))
        θ_ = (-π/2-np.arctan2(2*ϵ(parameters)-ϵ(parameters+I[i]*π/2)-ϵ(parameters-I[i]*π/2), ϵ(parameters+I[i]*π/2)-ϵ(parameters-I[i]*π/2)))
        θ = np.arctan2(np.sin(θ_), np.cos(θ_))
        plt.scatter([θ], [ϵ(parameters+θ*I[i])], marker='x')

        plt.plot(xs, es)
    plt.show()

def double_sinusoids(H, state_function, parameters, args=()): 
    def ϵ(x):
        return np.real(state_function(x, *args).conj().T@H@state_function(x, *args))
    I = np.eye(len(parameters))
    xs = np.linspace(-π, π, 101)
    for i in range(15):
        es = []
        def M(x):
            return ϵ(parameters+I[i]*x)
        for x in xs:
            es.append(M(x))

        A = float((M(0)+M(np.pi)))
        B = float((M(0)-M(np.pi)))
        C = float((M(np.pi/2)+M(-np.pi/2)))
        D = float((M(np.pi/2)-M(-np.pi/2)))
        E = float((M(np.pi/4)-M(-np.pi/4)))

        a, b, c, d = 1/4*(2*E-np.sqrt(2)*D), 1/4*(A-C), 1/2*D, 1/2*B

        P = np.sqrt(a**2+b**2)
        u = np.arctan2(b, a)
        
        Q = np.sqrt(c**2+d**2)
        v = np.arctan2(d, c)

        def f(x): return (P*np.sin(2*x+u)+Q*np.sin(x+v))

        plt.scatter(xs, f(xs)-f(xs)[0]+es[0], s=10)
        θ = minimize_scalar(f, bounds = [-np.pi, np.pi]).x
        plt.scatter([θ], [M(θ)], marker='x')
        plt.plot(xs, es)
    plt.show()

def rotosolve(H, state_function, initial_parameters, args=(), N_iters=10):
    """rotosolve

    :param H: hamiltonian.
    :param state_function: function taking parameters and returning complex vector.
    :param initial_parameters: initial parameters.
    :param args: extra arguments to state_function.
    :param N_iters: maximum number of optimization iterations.
    """
    S = []
    es = []
    I = np.eye(len(initial_parameters))
    params = initial_parameters
    for _ in range(N_iters):
        #H = Hamiltonian({'ZZ': 1, 'X': 0.5}).to_matrix()

        def ϵ(x):
            return np.real(state_function(x, *args).conj().T@H@state_function(x, *args))


        for i, _ in enumerate(params):
            θ_ = (-np.pi/2-np.arctan2(2*ϵ(params)-ϵ(params+I[i]*π/2)-ϵ(params-I[i]*π/2), ϵ(params+I[i]*π/2)-ϵ(params-I[i]*π/2)))
            params[i] += np.arctan2(np.sin(θ_), np.cos(θ_))
            params[i] = np.arctan2(np.sin(params[i]), np.cos(params[i]))
        sinusoids(H, state_function, params)
        es.append(ϵ(params))
        S.append(params.copy())
    return es, S

def double_rotosolve(H, state_function, initial_parameters, args=(), N_iters=5):
    """rotosolve

    :param H: hamiltonian.
    :param state_function: function taking parameters and returning complex vector.
    :param initial_parameters: initial parameters.
    :param args: extra arguments to state_function.
    :param N_iters: maximum number of optimization iterations.
    """
    S = []
    es = []
    I = np.eye(len(initial_parameters))
    params = initial_parameters
    for _ in range(N_iters):
        #H = Hamiltonian({'ZZ': 1, 'X': 0.5}).to_matrix()

        def ϵ(x):
            return np.real(state_function(x, *args).conj().T@H@state_function(x, *args))


        for i, _ in tqdm(enumerate(params)):
            def M(x):
                return ϵ(params+I[i]*x)

            A = float((M(0)+M(np.pi)))
            B = float((M(0)-M(np.pi)))
            C = float((M(np.pi/2)+M(-np.pi/2)))
            D = float((M(np.pi/2)-M(-np.pi/2)))
            E = float((M(np.pi/4)-M(-np.pi/4)))

            a, b, c, d = 1/4*(2*E-np.sqrt(2)*D), 1/4*(A-C), 1/2*D, 1/2*B

            P = np.sqrt(a**2+b**2)
            u = np.arctan2(b, a)
            
            Q = np.sqrt(c**2+d**2)
            v = np.arctan2(d, c)

            def f(x): return (P*np.sin(2*x+u)+Q*np.sin(x+v))

            θ_ = minimize_scalar(f, bounds = [-np.pi, np.pi]).x
            #θ_ = (-np.pi/2-np.arctan2(2*ϵ(params)-ϵ(params+I[i]*π/2)-ϵ(params-I[i]*π/2), ϵ(params+I[i]*π/2)-ϵ(params-I[i]*π/2)))
            params[i] += θ_#np.arctan2(np.sin(θ_), np.cos(θ_))
            #params[i] = np.arctan2(np.sin(params[i]), np.cos(params[i]))
        #double_sinusoids(H, state_function, params)
        es.append(ϵ(params))
        print(es[-1])
        S.append(params.copy())
    return es, S

H = Hamiltonian({'XX': -1, 'YY': -1, 'ZZ': -1}).to_matrix()
es, S = double_rotosolve(op_H(H), op_state, np.random.randn(30), N_iters=10)
plt.plot(es)
print(es[-1])
plt.show()

